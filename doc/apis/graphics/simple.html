<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="../../libs/easycss-1.3.1.min.css">
    <link rel="stylesheet" href="../../libs/prettify.css">
    <link rel="stylesheet" href="../../doc.css">
    <script src="../../libs/prettify.js"></script>
</head>

<body onload="prettyPrint()">
    <header>
        单一图形
    </header>
    <p>
        由于原始的绘图接口在绘制某些图形的时候并不够方便和高效，这里在此基础上添加一些常用图形绘制接口，是对原生的一种有效加强。
    </p>
    <h2>
        绘图对象
    </h2>
    <h4>
        SVG&amp;HTML
    </h4>
    <p>
        结点对象中提供的一系列方法就是为了使用这二种方式绘图而生的，可能你还会借助CSS，比如一棵常规树，使用CSS绘制可能比tree布局更有效。
    </p>
    <p>
        另外，如果你使用SVG绘图，下面对其进行了加强，但是为了保证灵活性，提供的接口并不是直接绘图，而是返回计算后的路径数据，这会在具体的接口中说明。
    </p>
    <h4>
        Canvas2D
    </h4>
    <pre class='prettyprint lang-js'>var pencil=$$('canvas').painter();</pre>
    <p>
        你依旧可以使用原来的方式获取画笔，不过，我们鼓励你使用上面的方法，另外，不要忘记了图层管理者，可能有时候，区域管理者你也不应该忘记配合使用。
    </p>
    <p>
        接着，我们还需要额外说明一下针对使用这里的方式绘图的统一流程。假设我们现在有一个绘图方法叫method：
    </p>
    <pre class='prettyprint lang-js'>// 获取method对应的绘图对象
var methodObj = $$.canvas.method(selector,{
    //  配置画笔
    "key":"value",
    ......
});
// 使用绘图对象绘图
methodObj(param);</pre>
    <p>
        获取method对应的绘图对象的时候，可以传递二个参数，分别标记绘图在哪里，画笔的配置。其中selector可以是任意一个合法的选择器（文档结点对象的基本的结点操作一节中定义的），或者2D画笔，比如传递上面的pencil。
    </p>
    <p>
        另外，这二个参数都不是必须的，你可以在后续配置或修改，比如下面这样：
    </p>
    <pre class='prettyprint lang-js'>methodObj.painter(selector);</pre>
    <p>
        设置绘图目标，selector和上面一样。返回绘图对象。
    </p>
    <pre class='prettyprint lang-js'>methodObj.config({
    "key":"value",
    ......
});</pre>
    <p>
        配置画笔，当然，直接通过pencil修改也是一样的，如果你不喜欢json这样方式。返回绘图对象。
    </p>
    <h2>
        画弧arc
    </h2>
    <h4>
        Canvas2D
    </h4>
    <p>
        这里和上面对比，就是把method换成了arc，我们只说明上面没有说明的部分。
    </p>
    <pre class='prettyprint lang-js'>var arc=$$.canvas.arc('canvas')
    // 设置弧圆心
    .setCenter(cx, cy)
    // 设置内外半径
    .setRadius(r1, r2);
    </pre>
    <p>
        上面多了二个配置语句，因为画弧形，你需要确定弧形的圆心和弧形有多宽，宽由内外半径差确定。另外，这二个方法都不是必须的，都有缺省值。返回绘图对象。
    </p>
    <pre class='prettyprint lang-js'>arc(beginA, rotateA[, r1, r2]);</pre>
    <p>
        最后绘制图形，传入弧形的起始弧度和终止弧度，另外内外半径是可选的，不传递就使用之前设置的或默认的，传递就使用传递的，不过不会被内部记录。返回画笔。
    </p>
    <h4>
        SVG
    </h4>
    <pre class='prettyprint lang-js'>var arc=$$.svg.arc()
    // 设置弧圆心
    .setCenter(cx, cy)
    // 设置内外半径
    .setRadius(r1, r2);

// 获取弧形路径
var d=arc(beginA, rotateA[, r1, r2]);</pre>
    <p>
        和canvas方式绘制大致一样，唯一的区别在与，没有画笔和样式的配置，返回的是path标签的d属性的值，因此具体样式的编辑就属于结点对象的事情了：
    </p>
    <pre class='prettyprint lang-js'>$$('path').attr('d', d)
    .css({
        'key':'value',
        ...
    });</pre>
</body>

</html>
